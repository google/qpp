// Copyright 2012 Traceur Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file was auto generated by build-parse-tree-transformer.js
// from trees.json
// Do not edit!

import * from '../syntax/trees/ParseTrees.js';
export class ParseTreeTransformer {
  transformAny(tree) {
    return tree && tree.transform(this);
  }
  transformList(list) {
    var builder = null;
    for (var index = 0; index < list.length; index++) {
      var element = list[index];
      var transformed = this.transformAny(element);
      if (builder != null || element != transformed) {
        if (builder == null) {
          builder = list.slice(0, index);
        }
        builder.push(transformed);
      }
    }
    return builder || list;
  }
  transformStateMachine(tree) {
    throw Error('State machines should not live outside of the GeneratorTransformer.');
  }

  transformArgumentList(tree) {
    var args = this.transformList(tree.args);
    if (args === tree.args) {
      return tree;
    }
    return new ArgumentList(tree.location, args);
  }
  transformArrayComprehension(tree) {
    var comprehensionList = this.transformList(tree.comprehensionList);
    var expression = this.transformAny(tree.expression);
    if (comprehensionList === tree.comprehensionList && expression === tree.expression) {
      return tree;
    }
    return new ArrayComprehension(tree.location, comprehensionList, expression);
  }
  transformArrayLiteralExpression(tree) {
    var elements = this.transformList(tree.elements);
    if (elements === tree.elements) {
      return tree;
    }
    return new ArrayLiteralExpression(tree.location, elements);
  }
  transformArrayPattern(tree) {
    var elements = this.transformList(tree.elements);
    if (elements === tree.elements) {
      return tree;
    }
    return new ArrayPattern(tree.location, elements);
  }
  transformArrowFunctionExpression(tree) {
    var formalParameters = this.transformAny(tree.formalParameters);
    var functionBody = this.transformAny(tree.functionBody);
    if (formalParameters === tree.formalParameters && functionBody === tree.functionBody) {
      return tree;
    }
    return new ArrowFunctionExpression(tree.location, formalParameters, functionBody);
  }
  transformAtNameDeclaration(tree) {
    var initializer = this.transformAny(tree.initializer);
    if (initializer === tree.initializer) {
      return tree;
    }
    return new AtNameDeclaration(tree.location, tree.atNameToken, initializer);
  }
  transformAtNameExpression(tree) {
    return tree;
  }
  transformAwaitStatement(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new AwaitStatement(tree.location, tree.identifier, expression);
  }
  transformBinaryOperator(tree) {
    var left = this.transformAny(tree.left);
    var right = this.transformAny(tree.right);
    if (left === tree.left && right === tree.right) {
      return tree;
    }
    return new BinaryOperator(tree.location, left, tree.operator, right);
  }
  transformBindingElement(tree) {
    var binding = this.transformAny(tree.binding);
    var initializer = this.transformAny(tree.initializer);
    if (binding === tree.binding && initializer === tree.initializer) {
      return tree;
    }
    return new BindingElement(tree.location, binding, initializer);
  }
  transformBindingIdentifier(tree) {
    return tree;
  }
  transformBlock(tree) {
    var statements = this.transformList(tree.statements);
    if (statements === tree.statements) {
      return tree;
    }
    return new Block(tree.location, statements);
  }
  transformBreakStatement(tree) {
    return tree;
  }
  transformCallExpression(tree) {
    var operand = this.transformAny(tree.operand);
    var args = this.transformAny(tree.args);
    if (operand === tree.operand && args === tree.args) {
      return tree;
    }
    return new CallExpression(tree.location, operand, args);
  }
  transformCascadeExpression(tree) {
    var operand = this.transformAny(tree.operand);
    var expressions = this.transformList(tree.expressions);
    if (operand === tree.operand && expressions === tree.expressions) {
      return tree;
    }
    return new CascadeExpression(tree.location, operand, expressions);
  }
  transformCaseClause(tree) {
    var expression = this.transformAny(tree.expression);
    var statements = this.transformList(tree.statements);
    if (expression === tree.expression && statements === tree.statements) {
      return tree;
    }
    return new CaseClause(tree.location, expression, statements);
  }
  transformCatch(tree) {
    var binding = this.transformAny(tree.binding);
    var catchBody = this.transformAny(tree.catchBody);
    if (binding === tree.binding && catchBody === tree.catchBody) {
      return tree;
    }
    return new Catch(tree.location, binding, catchBody);
  }
  transformClassDeclaration(tree) {
    var name = this.transformAny(tree.name);
    var superClass = this.transformAny(tree.superClass);
    var elements = this.transformList(tree.elements);
    if (name === tree.name && superClass === tree.superClass && elements === tree.elements) {
      return tree;
    }
    return new ClassDeclaration(tree.location, name, superClass, elements);
  }
  transformClassExpression(tree) {
    var name = this.transformAny(tree.name);
    var superClass = this.transformAny(tree.superClass);
    var elements = this.transformList(tree.elements);
    if (name === tree.name && superClass === tree.superClass && elements === tree.elements) {
      return tree;
    }
    return new ClassExpression(tree.location, name, superClass, elements);
  }
  transformCommaExpression(tree) {
    var expressions = this.transformList(tree.expressions);
    if (expressions === tree.expressions) {
      return tree;
    }
    return new CommaExpression(tree.location, expressions);
  }
  transformComprehensionFor(tree) {
    var left = this.transformAny(tree.left);
    var iterator = this.transformAny(tree.iterator);
    if (left === tree.left && iterator === tree.iterator) {
      return tree;
    }
    return new ComprehensionFor(tree.location, left, iterator);
  }
  transformComprehensionIf(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new ComprehensionIf(tree.location, expression);
  }
  transformConditionalExpression(tree) {
    var condition = this.transformAny(tree.condition);
    var left = this.transformAny(tree.left);
    var right = this.transformAny(tree.right);
    if (condition === tree.condition && left === tree.left && right === tree.right) {
      return tree;
    }
    return new ConditionalExpression(tree.location, condition, left, right);
  }
  transformContinueStatement(tree) {
    return tree;
  }
  transformCoverFormals(tree) {
    var expressions = this.transformList(tree.expressions);
    if (expressions === tree.expressions) {
      return tree;
    }
    return new CoverFormals(tree.location, expressions);
  }
  transformDebuggerStatement(tree) {
    return tree;
  }
  transformDefaultClause(tree) {
    var statements = this.transformList(tree.statements);
    if (statements === tree.statements) {
      return tree;
    }
    return new DefaultClause(tree.location, statements);
  }
  transformDoWhileStatement(tree) {
    var body = this.transformAny(tree.body);
    var condition = this.transformAny(tree.condition);
    if (body === tree.body && condition === tree.condition) {
      return tree;
    }
    return new DoWhileStatement(tree.location, body, condition);
  }
  transformEmptyStatement(tree) {
    return tree;
  }
  transformExportDeclaration(tree) {
    var declaration = this.transformAny(tree.declaration);
    if (declaration === tree.declaration) {
      return tree;
    }
    return new ExportDeclaration(tree.location, declaration);
  }
  transformExportMapping(tree) {
    var moduleExpression = this.transformAny(tree.moduleExpression);
    var specifierSet = this.transformAny(tree.specifierSet);
    if (moduleExpression === tree.moduleExpression && specifierSet === tree.specifierSet) {
      return tree;
    }
    return new ExportMapping(tree.location, moduleExpression, specifierSet);
  }
  transformExportMappingList(tree) {
    var paths = this.transformList(tree.paths);
    if (paths === tree.paths) {
      return tree;
    }
    return new ExportMappingList(tree.location, paths);
  }
  transformExportSpecifier(tree) {
    return tree;
  }
  transformExportSpecifierSet(tree) {
    var specifiers = this.transformList(tree.specifiers);
    if (specifiers === tree.specifiers) {
      return tree;
    }
    return new ExportSpecifierSet(tree.location, specifiers);
  }
  transformExportStar(tree) {
    return tree;
  }
  transformExpressionStatement(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new ExpressionStatement(tree.location, expression);
  }
  transformFinally(tree) {
    var block = this.transformAny(tree.block);
    if (block === tree.block) {
      return tree;
    }
    return new Finally(tree.location, block);
  }
  transformForInStatement(tree) {
    var initializer = this.transformAny(tree.initializer);
    var collection = this.transformAny(tree.collection);
    var body = this.transformAny(tree.body);
    if (initializer === tree.initializer && collection === tree.collection && body === tree.body) {
      return tree;
    }
    return new ForInStatement(tree.location, initializer, collection, body);
  }
  transformForOfStatement(tree) {
    var initializer = this.transformAny(tree.initializer);
    var collection = this.transformAny(tree.collection);
    var body = this.transformAny(tree.body);
    if (initializer === tree.initializer && collection === tree.collection && body === tree.body) {
      return tree;
    }
    return new ForOfStatement(tree.location, initializer, collection, body);
  }
  transformForStatement(tree) {
    var initializer = this.transformAny(tree.initializer);
    var condition = this.transformAny(tree.condition);
    var increment = this.transformAny(tree.increment);
    var body = this.transformAny(tree.body);
    if (initializer === tree.initializer && condition === tree.condition && increment === tree.increment && body === tree.body) {
      return tree;
    }
    return new ForStatement(tree.location, initializer, condition, increment, body);
  }
  transformFormalParameterList(tree) {
    var parameters = this.transformList(tree.parameters);
    if (parameters === tree.parameters) {
      return tree;
    }
    return new FormalParameterList(tree.location, parameters);
  }
  transformFunctionDeclaration(tree) {
    var name = this.transformAny(tree.name);
    var formalParameterList = this.transformAny(tree.formalParameterList);
    var functionBody = this.transformAny(tree.functionBody);
    if (name === tree.name && formalParameterList === tree.formalParameterList && functionBody === tree.functionBody) {
      return tree;
    }
    return new FunctionDeclaration(tree.location, name, tree.isGenerator, formalParameterList, functionBody);
  }
  transformFunctionExpression(tree) {
    var name = this.transformAny(tree.name);
    var formalParameterList = this.transformAny(tree.formalParameterList);
    var functionBody = this.transformAny(tree.functionBody);
    if (name === tree.name && formalParameterList === tree.formalParameterList && functionBody === tree.functionBody) {
      return tree;
    }
    return new FunctionExpression(tree.location, name, tree.isGenerator, formalParameterList, functionBody);
  }
  transformGeneratorComprehension(tree) {
    var comprehensionList = this.transformList(tree.comprehensionList);
    var expression = this.transformAny(tree.expression);
    if (comprehensionList === tree.comprehensionList && expression === tree.expression) {
      return tree;
    }
    return new GeneratorComprehension(tree.location, comprehensionList, expression);
  }
  transformGetAccessor(tree) {
    var body = this.transformAny(tree.body);
    if (body === tree.body) {
      return tree;
    }
    return new GetAccessor(tree.location, tree.isStatic, tree.name, body);
  }
  transformIdentifierExpression(tree) {
    return tree;
  }
  transformIfStatement(tree) {
    var condition = this.transformAny(tree.condition);
    var ifClause = this.transformAny(tree.ifClause);
    var elseClause = this.transformAny(tree.elseClause);
    if (condition === tree.condition && ifClause === tree.ifClause && elseClause === tree.elseClause) {
      return tree;
    }
    return new IfStatement(tree.location, condition, ifClause, elseClause);
  }
  transformImportBinding(tree) {
    var moduleExpression = this.transformAny(tree.moduleExpression);
    var importSpecifierSet = this.transformAny(tree.importSpecifierSet);
    if (moduleExpression === tree.moduleExpression && importSpecifierSet === tree.importSpecifierSet) {
      return tree;
    }
    return new ImportBinding(tree.location, moduleExpression, importSpecifierSet);
  }
  transformImportDeclaration(tree) {
    var importPathList = this.transformList(tree.importPathList);
    if (importPathList === tree.importPathList) {
      return tree;
    }
    return new ImportDeclaration(tree.location, importPathList);
  }
  transformImportSpecifier(tree) {
    return tree;
  }
  transformImportSpecifierSet(tree) {
    var specifiers = this.transformList(tree.specifiers);
    if (specifiers === tree.specifiers) {
      return tree;
    }
    return new ImportSpecifierSet(tree.location, specifiers);
  }
  transformLabelledStatement(tree) {
    var statement = this.transformAny(tree.statement);
    if (statement === tree.statement) {
      return tree;
    }
    return new LabelledStatement(tree.location, tree.name, statement);
  }
  transformLiteralExpression(tree) {
    return tree;
  }
  transformMemberExpression(tree) {
    var operand = this.transformAny(tree.operand);
    if (operand === tree.operand) {
      return tree;
    }
    return new MemberExpression(tree.location, operand, tree.memberName);
  }
  transformMemberLookupExpression(tree) {
    var operand = this.transformAny(tree.operand);
    var memberExpression = this.transformAny(tree.memberExpression);
    if (operand === tree.operand && memberExpression === tree.memberExpression) {
      return tree;
    }
    return new MemberLookupExpression(tree.location, operand, memberExpression);
  }
  transformMissingPrimaryExpression(tree) {
    return tree;
  }
  transformModuleDeclaration(tree) {
    var specifiers = this.transformList(tree.specifiers);
    if (specifiers === tree.specifiers) {
      return tree;
    }
    return new ModuleDeclaration(tree.location, specifiers);
  }
  transformModuleDefinition(tree) {
    var elements = this.transformList(tree.elements);
    if (elements === tree.elements) {
      return tree;
    }
    return new ModuleDefinition(tree.location, tree.name, elements);
  }
  transformModuleExpression(tree) {
    var reference = this.transformAny(tree.reference);
    if (reference === tree.reference) {
      return tree;
    }
    return new ModuleExpression(tree.location, reference, tree.identifiers);
  }
  transformModuleRequire(tree) {
    return tree;
  }
  transformModuleSpecifier(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new ModuleSpecifier(tree.location, tree.identifier, expression);
  }
  transformNameStatement(tree) {
    var declarations = this.transformList(tree.declarations);
    if (declarations === tree.declarations) {
      return tree;
    }
    return new NameStatement(tree.location, declarations);
  }
  transformNewExpression(tree) {
    var operand = this.transformAny(tree.operand);
    var args = this.transformAny(tree.args);
    if (operand === tree.operand && args === tree.args) {
      return tree;
    }
    return new NewExpression(tree.location, operand, args);
  }
  transformObjectLiteralExpression(tree) {
    var propertyNameAndValues = this.transformList(tree.propertyNameAndValues);
    if (propertyNameAndValues === tree.propertyNameAndValues) {
      return tree;
    }
    return new ObjectLiteralExpression(tree.location, propertyNameAndValues);
  }
  transformObjectPattern(tree) {
    var fields = this.transformList(tree.fields);
    if (fields === tree.fields) {
      return tree;
    }
    return new ObjectPattern(tree.location, fields);
  }
  transformObjectPatternField(tree) {
    var element = this.transformAny(tree.element);
    if (element === tree.element) {
      return tree;
    }
    return new ObjectPatternField(tree.location, tree.identifier, element);
  }
  transformParenExpression(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new ParenExpression(tree.location, expression);
  }
  transformPostfixExpression(tree) {
    var operand = this.transformAny(tree.operand);
    if (operand === tree.operand) {
      return tree;
    }
    return new PostfixExpression(tree.location, operand, tree.operator);
  }
  transformPredefinedType(tree) {
    return tree;
  }
  transformProgram(tree) {
    var programElements = this.transformList(tree.programElements);
    if (programElements === tree.programElements) {
      return tree;
    }
    return new Program(tree.location, programElements);
  }
  transformPropertyMethodAssignment(tree) {
    var formalParameterList = this.transformAny(tree.formalParameterList);
    var functionBody = this.transformAny(tree.functionBody);
    if (formalParameterList === tree.formalParameterList && functionBody === tree.functionBody) {
      return tree;
    }
    return new PropertyMethodAssignment(tree.location, tree.isStatic, tree.isGenerator, tree.name, formalParameterList, functionBody);
  }
  transformPropertyNameAssignment(tree) {
    var value = this.transformAny(tree.value);
    if (value === tree.value) {
      return tree;
    }
    return new PropertyNameAssignment(tree.location, tree.name, value);
  }
  transformPropertyNameShorthand(tree) {
    return tree;
  }
  transformRestParameter(tree) {
    var identifier = this.transformAny(tree.identifier);
    if (identifier === tree.identifier) {
      return tree;
    }
    return new RestParameter(tree.location, identifier);
  }
  transformReturnStatement(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new ReturnStatement(tree.location, expression);
  }
  transformSetAccessor(tree) {
    var parameter = this.transformAny(tree.parameter);
    var body = this.transformAny(tree.body);
    if (parameter === tree.parameter && body === tree.body) {
      return tree;
    }
    return new SetAccessor(tree.location, tree.isStatic, tree.name, parameter, body);
  }
  transformSpreadExpression(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new SpreadExpression(tree.location, expression);
  }
  transformSpreadPatternElement(tree) {
    var lvalue = this.transformAny(tree.lvalue);
    if (lvalue === tree.lvalue) {
      return tree;
    }
    return new SpreadPatternElement(tree.location, lvalue);
  }
  transformSuperExpression(tree) {
    return tree;
  }
  transformSwitchStatement(tree) {
    var expression = this.transformAny(tree.expression);
    var caseClauses = this.transformList(tree.caseClauses);
    if (expression === tree.expression && caseClauses === tree.caseClauses) {
      return tree;
    }
    return new SwitchStatement(tree.location, expression, caseClauses);
  }
  transformTemplateLiteralExpression(tree) {
    var operand = this.transformAny(tree.operand);
    var elements = this.transformList(tree.elements);
    if (operand === tree.operand && elements === tree.elements) {
      return tree;
    }
    return new TemplateLiteralExpression(tree.location, operand, elements);
  }
  transformTemplateLiteralPortion(tree) {
    return tree;
  }
  transformTemplateSubstitution(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new TemplateSubstitution(tree.location, expression);
  }
  transformThisExpression(tree) {
    return tree;
  }
  transformThrowStatement(tree) {
    var value = this.transformAny(tree.value);
    if (value === tree.value) {
      return tree;
    }
    return new ThrowStatement(tree.location, value);
  }
  transformTryStatement(tree) {
    var body = this.transformAny(tree.body);
    var catchBlock = this.transformAny(tree.catchBlock);
    var finallyBlock = this.transformAny(tree.finallyBlock);
    if (body === tree.body && catchBlock === tree.catchBlock && finallyBlock === tree.finallyBlock) {
      return tree;
    }
    return new TryStatement(tree.location, body, catchBlock, finallyBlock);
  }
  transformTypeName(tree) {
    var moduleName = this.transformAny(tree.moduleName);
    if (moduleName === tree.moduleName) {
      return tree;
    }
    return new TypeName(tree.location, moduleName, tree.name);
  }
  transformUnaryExpression(tree) {
    var operand = this.transformAny(tree.operand);
    if (operand === tree.operand) {
      return tree;
    }
    return new UnaryExpression(tree.location, tree.operator, operand);
  }
  transformVariableDeclaration(tree) {
    var lvalue = this.transformAny(tree.lvalue);
    var typeAnnotation = this.transformAny(tree.typeAnnotation);
    var initializer = this.transformAny(tree.initializer);
    if (lvalue === tree.lvalue && typeAnnotation === tree.typeAnnotation && initializer === tree.initializer) {
      return tree;
    }
    return new VariableDeclaration(tree.location, lvalue, typeAnnotation, initializer);
  }
  transformVariableDeclarationList(tree) {
    var declarations = this.transformList(tree.declarations);
    if (declarations === tree.declarations) {
      return tree;
    }
    return new VariableDeclarationList(tree.location, tree.declarationType, declarations);
  }
  transformVariableStatement(tree) {
    var declarations = this.transformAny(tree.declarations);
    if (declarations === tree.declarations) {
      return tree;
    }
    return new VariableStatement(tree.location, declarations);
  }
  transformWhileStatement(tree) {
    var condition = this.transformAny(tree.condition);
    var body = this.transformAny(tree.body);
    if (condition === tree.condition && body === tree.body) {
      return tree;
    }
    return new WhileStatement(tree.location, condition, body);
  }
  transformWithStatement(tree) {
    var expression = this.transformAny(tree.expression);
    var body = this.transformAny(tree.body);
    if (expression === tree.expression && body === tree.body) {
      return tree;
    }
    return new WithStatement(tree.location, expression, body);
  }
  transformYieldExpression(tree) {
    var expression = this.transformAny(tree.expression);
    if (expression === tree.expression) {
      return tree;
    }
    return new YieldExpression(tree.location, expression, tree.isYieldFor);
  }
}
